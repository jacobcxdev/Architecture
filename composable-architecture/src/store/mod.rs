//! `Store`: a runtime for reducers.
//!
use std::thread::{JoinHandle, Thread};

use crate::dependencies::Tuple;
use crate::Reducer;
use channel::Sender;

pub(crate) mod channel;
mod runtime;

pub(crate) mod testing;

#[doc = include_str!("README.md")]
pub struct Store<State: Reducer> {
    sender: Sender<Result<<State as Reducer>::Action, Thread>>,
    handle: JoinHandle<<State as Reducer>::Output>,
}

impl<State: Reducer> Store<State> {
    /// Creates a new `Store` with `state` as its initial state.
    ///
    /// If `State` is not [`Send`], then [`with_dependencies`][`Store::with_dependencies`] (or [`with_dependency`][`Store::with_dependency`])
    /// can be used instead.
    ///
    /// # Requirements
    /// This constructor requires `State: Send` because the value is moved into the runtime thread.
    pub fn with_initial(state: State) -> Self
    where
        State: Send + 'static,
        <State as Reducer>::Action: Send,
        <State as Reducer>::Output: Send + From<State>,
    {
        Store::runtime(|| state, || ((),))
    }

    /// Creates a new `Store` with its initial state generated by functions and a second function that
    /// generates a tuple of the `Store`’s `dependencies`.
    ///
    /// Can be used if `State` is not [`Send`], but the arguments used to construct it are.
    ///
    /// This is also the recommended entrypoint for tests or apps that want to inject dependencies
    /// without relying on global state.
    pub fn with_dependencies<F, D, T>(with: F, dependencies: D) -> Self
    where
        F: (FnOnce() -> State) + Send + 'static,
        D: (FnOnce() -> T) + Send + 'static,
        T: Tuple + 'static,
        <State as Reducer>::Action: Send + 'static,
        <State as Reducer>::Output: Send + From<State> + 'static,
    {
        Store::runtime(with, dependencies)
    }

    /// Creates a new `Store` with its initial state and a (single) dependency generated by functions.
    ///
    /// This is simple wrapper around [`with_dependencies`][`Store::with_dependencies`].
    pub fn with_dependency<F, D, T>(with: F, dependency: D) -> Self
    where
        F: (FnOnce() -> State) + Send + 'static,
        D: (FnOnce() -> T) + Send + 'static,
        T: 'static,
        <State as Reducer>::Action: Send + 'static,
        <State as Reducer>::Output: Send + From<State> + 'static,
    {
        Store::runtime(with, || (dependency(),))
    }

    /// Calls the `Store`’s [`Reducer`][`crate::Reducer`] with `action`.
    ///
    /// Takes an [`Into<Action>`] so that both child and parent `Action`s may be sent easily.
    ///
    /// This method is non-blocking: it enqueues the action for the runtime thread to process.
    pub fn send(&self, action: impl Into<<State as Reducer>::Action>) {
        self.sender.send(Ok(action.into()))
    }

    /// Calls the `Store`’s [`Reducer`][`crate::Reducer`] with `action`. and waits until
    /// the `Reducer` has performed the `action`.
    /// ## Note
    /// - This is a blocking call and is usually not what is wanted.
    /// - It does not wait for asynchronous work spawned by effects (tasks/futures/streams).
    ///
    /// However, `sync` *does* wait for any synchronous follow-up actions emitted during this
    /// action’s handling to be drained, since the runtime drains those before it returns to
    /// awaiting the next external action.
    pub fn sync(&self, action: impl Into<<State as Reducer>::Action>) {
        self.sender.sync(Ok(action.into()))
    }

    /// Stops the `Store`’s runtime and returns its current `state` value.  
    ///
    /// # Note
    /// Care should be exercised when using this method in applications that utilize
    /// asynchronous [`Effects`][`crate::effects::Effects`]. `into_inner` makes a best effort to
    /// allow pending tasks to run before shutdown, but completion is not guaranteed.
    pub fn into_inner(self) -> <State as Reducer>::Output {
        self.sender.send(Err(std::thread::current()));
        std::thread::park(); // waiting for any async tasks to finish up

        drop(self.sender); // ends the runtime’s (outer) while-let
        std::thread::yield_now(); // give it time to shut down
        self.handle.join().unwrap()
    }
}

impl<State: Reducer> Default for Store<State>
where
    State: Default,
    <State as Reducer>::Action: Send + 'static,
    <State as Reducer>::Output: Send + From<State> + 'static,
{
    /// Creates a new `Store` with a default initial state.
    fn default() -> Self {
        Store::with_dependencies(|| State::default(), || ((),))
    }
}
